'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var evaluateSimple = _interopDefault(require('babel-helper-evaluate-path'));
var evaluateComplex = _interopDefault(require('linaria/lib/babel/evaluate'));

/**
 * Created by schwarzkopfb on 15/11/17.
 */

/**
 * FNV-1a hash generation init value.
 * It's exposed, because this allows user to override it.
 *
 * @type {number}
 */
hash.BASE = 0x811c9dc5;

/**
 * Generates 32 bit FNV-1a hash from the given string.
 * As explained here: http://isthe.com/chongo/tech/comp/fnv/
 *
 * @param s {string} String to generate hash from.
 * @returns {number} The result integer hash.
 */
function hash(s) {
    var h = hash.BASE;

    for (var i = 0, l = s.length; i < l; i++) {
        h ^= s.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }

    return h >>> 0
}

var fnv1a = hash;

function capitalizeString(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function prefixProperty(prefixProperties, property, style) {
  if (prefixProperties.hasOwnProperty(property)) {
    var newStyle = {};
    var requiredPrefixes = prefixProperties[property];
    var capitalizedProperty = capitalizeString(property);
    var keys = Object.keys(style);
    for (var i = 0; i < keys.length; i++) {
      var styleProperty = keys[i];
      if (styleProperty === property) {
        for (var j = 0; j < requiredPrefixes.length; j++) {
          newStyle[requiredPrefixes[j] + capitalizedProperty] = style[property];
        }
      }
      newStyle[styleProperty] = style[styleProperty];
    }
    return newStyle;
  }
  return style;
}

function prefixValue(plugins, property, value, style, metaData) {
  for (var i = 0, len = plugins.length; i < len; ++i) {
    var processedValue = plugins[i](property, value, style, metaData);

    // we can stop processing if a value is returned
    // as all plugin criteria are unique
    if (processedValue) {
      return processedValue;
    }
  }
}

function addIfNew(list, value) {
  if (list.indexOf(value) === -1) {
    list.push(value);
  }
}

function addNewValuesOnly(list, values) {
  if (Array.isArray(values)) {
    for (var i = 0, len = values.length; i < len; ++i) {
      addIfNew(list, values[i]);
    }
  } else {
    addIfNew(list, values);
  }
}

function isObject(value) {
  return value instanceof Object && !Array.isArray(value);
}

function createPrefixer(_ref) {
  var prefixMap = _ref.prefixMap,
      plugins = _ref.plugins;

  return function prefix(style) {
    for (var property in style) {
      var value = style[property];

      // handle nested objects
      if (isObject(value)) {
        style[property] = prefix(value);
        // handle array values
      } else if (Array.isArray(value)) {
        var combinedValue = [];

        for (var i = 0, len = value.length; i < len; ++i) {
          var processedValue = prefixValue(plugins, property, value[i], style, prefixMap);
          addNewValuesOnly(combinedValue, processedValue || value[i]);
        }

        // only modify the value if it was touched
        // by any plugin to prevent unnecessary mutations
        if (combinedValue.length > 0) {
          style[property] = combinedValue;
        }
      } else {
        var _processedValue = prefixValue(plugins, property, value, style, prefixMap);

        // only modify the value if it was touched
        // by any plugin to prevent unnecessary mutations
        if (_processedValue) {
          style[property] = _processedValue;
        }

        style = prefixProperty(prefixMap, property, style);
      }
    }

    return style;
  };
}

var w = ["Webkit"];
var m = ["Moz"];
var ms = ["ms"];
var wm = ["Webkit", "Moz"];
var wms = ["Webkit", "ms"];
var wmms = ["Webkit", "Moz", "ms"];

var data = {
  plugins: [],
  prefixMap: { "appearance": wm, "textEmphasisPosition": w, "textEmphasis": w, "textEmphasisStyle": w, "textEmphasisColor": w, "boxDecorationBreak": w, "maskImage": w, "maskMode": w, "maskRepeat": w, "maskPosition": w, "maskClip": w, "maskOrigin": w, "maskSize": w, "maskComposite": w, "mask": w, "maskBorderSource": w, "maskBorderMode": w, "maskBorderSlice": w, "maskBorderWidth": w, "maskBorderOutset": w, "maskBorderRepeat": w, "maskBorder": w, "maskType": w, "textDecorationStyle": w, "textDecorationSkip": w, "textDecorationLine": w, "textDecorationColor": w, "userSelect": wmms, "backdropFilter": w, "fontKerning": w, "scrollSnapType": wms, "scrollSnapPointsX": wms, "scrollSnapPointsY": wms, "scrollSnapDestination": wms, "scrollSnapCoordinate": wms, "clipPath": w, "shapeImageThreshold": w, "shapeImageMargin": w, "shapeImageOutside": w, "filter": w, "hyphens": wms, "flowInto": wms, "flowFrom": wms, "breakBefore": wms, "breakAfter": wms, "breakInside": wms, "regionFragment": wms, "writingMode": wms, "textOrientation": w, "tabSize": m, "fontFeatureSettings": w, "columnCount": w, "columnFill": w, "columnGap": w, "columnRule": w, "columnRuleColor": w, "columnRuleStyle": w, "columnRuleWidth": w, "columns": w, "columnSpan": w, "columnWidth": w, "wrapFlow": ms, "wrapThrough": ms, "wrapMargin": ms, "gridTemplateColumns": ms, "gridTemplateRows": ms, "gridTemplateAreas": ms, "gridTemplate": ms, "gridAutoColumns": ms, "gridAutoRows": ms, "gridAutoFlow": ms, "grid": ms, "gridRowStart": ms, "gridColumnStart": ms, "gridRowEnd": ms, "gridRow": ms, "gridColumn": ms, "gridColumnEnd": ms, "gridColumnGap": ms, "gridRowGap": ms, "gridArea": ms, "gridGap": ms, "textSizeAdjust": wms }
};

// https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip#Browser_compatibility
function backgroundClip(property, value) {
  if (typeof value === 'string' && value === 'text') {
    return ['-webkit-text', 'text'];
  }
}

var prefixes = ['-webkit-', '-moz-', ''];

var values = {
  'zoom-in': true,
  'zoom-out': true,
  grab: true,
  grabbing: true
};

function cursor(property, value) {
  if (property === 'cursor' && values.hasOwnProperty(value)) {
    return prefixes.map(function (prefix) {
      return prefix + value;
    });
  }
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var isPrefixedValue_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPrefixedValue;
var regex = /-webkit-|-moz-|-ms-/;

function isPrefixedValue(value) {
  return typeof value === 'string' && regex.test(value);
}
module.exports = exports['default'];
});

var isPrefixedValue = unwrapExports(isPrefixedValue_1);

// http://caniuse.com/#search=cross-fade
var prefixes$1 = ['-webkit-', ''];

function crossFade(property, value) {
  if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('cross-fade(') > -1) {
    return prefixes$1.map(function (prefix) {
      return value.replace(/cross-fade\(/g, prefix + 'cross-fade(');
    });
  }
}

// http://caniuse.com/#feat=css-filter-function
var prefixes$2 = ['-webkit-', ''];

function filter(property, value) {
  if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('filter(') > -1) {
    return prefixes$2.map(function (prefix) {
      return value.replace(/filter\(/g, prefix + 'filter(');
    });
  }
}

var values$1 = {
  flex: ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex', 'flex'],
  'inline-flex': ['-webkit-inline-box', '-moz-inline-box', '-ms-inline-flexbox', '-webkit-inline-flex', 'inline-flex']
};

function flex(property, value) {
  if (property === 'display' && values$1.hasOwnProperty(value)) {
    return values$1[value];
  }
}

var alternativeValues = {
  'space-around': 'justify',
  'space-between': 'justify',
  'flex-start': 'start',
  'flex-end': 'end',
  'wrap-reverse': 'multiple',
  wrap: 'multiple'
};

var alternativeProps = {
  alignItems: 'WebkitBoxAlign',
  justifyContent: 'WebkitBoxPack',
  flexWrap: 'WebkitBoxLines',
  flexGrow: 'WebkitBoxFlex'
};

function flexboxOld(property, value, style) {
  if (property === 'flexDirection' && typeof value === 'string') {
    if (value.indexOf('column') > -1) {
      style.WebkitBoxOrient = 'vertical';
    } else {
      style.WebkitBoxOrient = 'horizontal';
    }
    if (value.indexOf('reverse') > -1) {
      style.WebkitBoxDirection = 'reverse';
    } else {
      style.WebkitBoxDirection = 'normal';
    }
  }
  if (alternativeProps.hasOwnProperty(property)) {
    style[alternativeProps[property]] = alternativeValues[value] || value;
  }
}

var prefixes$3 = ['-webkit-', '-moz-', ''];
var values$2 = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/gi;

function gradient(property, value) {
  if (typeof value === 'string' && !isPrefixedValue(value) && values$2.test(value)) {
    return prefixes$3.map(function (prefix) {
      return value.replace(values$2, function (grad) {
        return prefix + grad;
      });
    });
  }
}

// http://caniuse.com/#feat=css-image-set
var prefixes$4 = ['-webkit-', ''];

function imageSet(property, value) {
  if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('image-set(') > -1) {
    return prefixes$4.map(function (prefix) {
      return value.replace(/image-set\(/g, prefix + 'image-set(');
    });
  }
}

function position(property, value) {
  if (property === 'position' && value === 'sticky') {
    return ['-webkit-sticky', 'sticky'];
  }
}

var prefixes$5 = ['-webkit-', '-moz-', ''];

var properties = {
  maxHeight: true,
  maxWidth: true,
  width: true,
  height: true,
  columnWidth: true,
  minWidth: true,
  minHeight: true
};
var values$3 = {
  'min-content': true,
  'max-content': true,
  'fill-available': true,
  'fit-content': true,
  'contain-floats': true
};

function sizing(property, value) {
  if (properties.hasOwnProperty(property) && values$3.hasOwnProperty(value)) {
    return prefixes$5.map(function (prefix) {
      return prefix + value;
    });
  }
}

var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};

function hyphenateStyleName(string) {
    return string in cache
    ? cache[string]
    : cache[string] = string
      .replace(uppercasePattern, '-$&')
      .toLowerCase()
      .replace(msPattern, '-ms-');
}

var hyphenateStyleName_1 = hyphenateStyleName;

var hyphenateProperty_1 = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hyphenateProperty;



var _hyphenateStyleName2 = _interopRequireDefault(hyphenateStyleName_1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hyphenateProperty(property) {
  return (0, _hyphenateStyleName2.default)(property);
}
module.exports = exports['default'];
});

var hyphenateProperty = unwrapExports(hyphenateProperty_1);

var properties$1 = {
  transition: true,
  transitionProperty: true,
  WebkitTransition: true,
  WebkitTransitionProperty: true,
  MozTransition: true,
  MozTransitionProperty: true
};

var prefixMapping = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  ms: '-ms-'
};

function prefixValue$1(value, propertyPrefixMap) {
  if (isPrefixedValue(value)) {
    return value;
  }

  // only split multi values, not cubic beziers
  var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);

  for (var i = 0, len = multipleValues.length; i < len; ++i) {
    var singleValue = multipleValues[i];
    var values = [singleValue];
    for (var property in propertyPrefixMap) {
      var dashCaseProperty = hyphenateProperty(property);

      if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== 'order') {
        var prefixes = propertyPrefixMap[property];
        for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
          // join all prefixes and create a new value
          values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
        }
      }
    }

    multipleValues[i] = values.join(',');
  }

  return multipleValues.join(',');
}

function transition(property, value, style, propertyPrefixMap) {
  // also check for already prefixed transitions
  if (typeof value === 'string' && properties$1.hasOwnProperty(property)) {
    var outputValue = prefixValue$1(value, propertyPrefixMap);
    // if the property is already prefixed
    var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
      return !/-moz-|-ms-/.test(val);
    }).join(',');

    if (property.indexOf('Webkit') > -1) {
      return webkitOutput;
    }

    var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
      return !/-webkit-|-ms-/.test(val);
    }).join(',');

    if (property.indexOf('Moz') > -1) {
      return mozOutput;
    }

    style['Webkit' + capitalizeString(property)] = webkitOutput;
    style['Moz' + capitalizeString(property)] = mozOutput;
    return outputValue;
  }
}

var plugins = [backgroundClip, crossFade, cursor, filter, flexboxOld, gradient, imageSet, position, sizing, transition, flex];

var prefix = createPrefixer({
  prefixMap: data.prefixMap,
  plugins: plugins
});

const unitless = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true,
};

const shortHandProperties = [
  'animation',
  'background',
  'border',
  'border-bottom',
  'border-left',
  'border-radius',
  'border-right',
  'border-top',
  'column-rule',
  'columns',
  'flex',
  'flex-flow',
  'font',
  'grid',
  'grid-area',
  'grid-column',
  'grid-row',
  'grid-template',
  'list-style',
  'margin',
  'offset',
  'outline',
  'overflow',
  'padding',
  'place-content',
  'place-items',
  'place-self',
  'text-decoration',
  'transition',
];

// Fork of https://github.com/jxnblk/object-style

function createClassName(property, value, descendants, media) {
  return `dss_${fnv1a(property + descendants + media).toString(36)}-${fnv1a(
    String(value)
  ).toString(36)}`
}

const hyphenate = s => s.replace(/[A-Z]|^ms/g, '-$&').toLowerCase();
const strigifyDeclaration = dec => {
  let stringified = '';

  for (const prop in dec) {
    const value = dec[prop];
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        stringified += hyphenate(prop) + ':' + value[i] + ';';
      }
    } else {
      stringified += hyphenate(prop) + ':' + value + ';';
    }
  }
  return stringified
};
function createRule(className, declaration, descendants, media) {
  const cls = '.' + className;
  const selector = descendants
    ? descendants.replace(/^&/, cls).replace(/&/g, cls)
    : cls;
  const rule = selector + '{' + strigifyDeclaration(declaration) + '}';
  if (!media) return rule
  return media + '{' + rule + '}'
}

const parse = (obj, descendants, media, opts) => {
  const rules = {};

  for (const key in obj) {
    let value = obj[key];
    if (value === null || value === undefined) continue
    switch (Object.prototype.toString.call(value)) {
      case '[object Object]': {
        const parsed =
          key.charAt(0) === '@'
            ? parse(value, descendants, key, opts)
            : parse(value, descendants + key, media, opts);
        Object.assign(rules, parsed);
        break
      }
      default: {
        const className = createClassName(key, value, descendants, media);
        if (rules[className]) {
          break
        }
        if (!unitless[key]) {
          if (typeof value === 'number') {
            if (value !== 0) {
              value += 'px';
            }
          } else if (Array.isArray(value)) {
            value = value.map(v => {
              if (typeof v === 'number' && v !== 0) {
                return v + 'px'
              }
              return v
            });
          }
        }
        const declaration = prefix({ [key]: value });
        const rule = createRule(className, declaration, descendants, media);
        rules[className] = rule;
        break
      }
    }
  }

  return rules
};

var compile = obj => {
  if (!obj) {
    throw new Error('DSS parser invoked without a mandatory styles object.')
  }
  return parse(obj, '', '')
};

function error(message) {
  throw new Error(`style-sheet: ${message}`)
}

function validate(obj) {
  for (const k in obj) {
    const key = k.trim();
    const value = obj[key];
    if (value === null) continue
    const isDeclaration =
      Object.prototype.toString.call(value) !== '[object Object]';
    validateStr(key, isDeclaration);
    if (!isDeclaration) {
      validate(value);
    } else if (typeof value === 'string' && /!\s*important/.test(value)) {
      error('!important is not allowed');
    }
  }
}

function validateStr(key, isDeclaration) {
  if (isDeclaration) {
    // Value
    if (shortHandProperties.includes(key)) {
      error(
        '`' +
          key +
          "`: style-sheet does't support shorthand properties at the moment. This CSS feature will likely be supported in the future. Please expand your shorthand properties for now." +
          `\n Can't remember what is the long form for \`${key}\`? Ask Google ðŸ‘‰  https://google.com/search?q=${encodeURIComponent(
            `css ${key} properties`
          )}`
      );
    }
    return
  }

  if (key.charAt(0) === '@') {
    return
  }

  // Selector

  if (key.split(',').length > 1) {
    error(`Invalid nested selector: '${key}'. Selectors cannot be grouped.`);
  }

  if (/::?(after|before|first-letter|first-line)/.test(key)) {
    error(
      `Detected pseudo-element: '${key}'. Pseudo-elements are not supported. Please use regular elements.`
    );
  }

  if (/:(matches|has|not|lang|any|current)/.test(key)) {
    error(`Detected unsupported pseudo-class: '${key}'.`);
  }

  const split = key.split(/\s*[+>~]\s*/g);

  switch (split.length) {
    case 2:
      if (split[0].charAt(0) !== ':') {
        error(
          `Invalid nested selector: '${key}'. ` +
            'The left part of a combinator selector must be a pseudo-class eg. `:hover`.'
        );
      }
      if (split[1] !== '&') {
        error(
          `Invalid nested selector: '${key}'. ` +
            'The right part of a combinator selector must be `&`.'
        );
      }
      break
    case 1:
      if (split[0].indexOf(' ') > -1) {
        error(
          `Invalid nested selector: ${key}. Complex selectors are not supported.`
        );
      }
      if (split[0].charAt(0) !== '&') {
        error(
          `Invalid nested selector: '${key}'. ` +
            'A pseudo-class selector should reference its parent with `&` eg. `&:hover {}`.'
        );
      }
      break
    default:
      error(`Invalid nested selector: ${key}.`);
  }

  if (/\[/.test(key)) {
    error(
      `Invalid selector: ${key}. Cannot use attribute selectors, please use only class selectors.`
    );
  }
}

function Sheet() {
  this.cssRules = { length: 0 };
  this.insertRule = (rule, index = this.cssRules.length) => {
    if (index > this.cssRules.length) {
      throw new Error('IndexSizeError')
    }
    this.cssRules[index] = { cssText: rule };
    const insertedIndex = index;
    if (index === this.cssRules.length) {
      this.cssRules.length++;
    }
    return insertedIndex
  };
}

function createSheet() {
  return new Sheet()
}

function cssRulesToString(rules) {
  return Array.prototype.reduce.call(
    rules,
    // eslint-disable-next-line prefer-arrow-callback
    function(css, rule) {
      return css + rule.cssText
    },
    ''
  )
}

function fromServer(sheets) {
  let css = '';
  const { sheet, mediaSheet, linkSheet } = sheets;

  // We likely are server side rendering.
  if (!sheet.ownerNode) {
    return css
  }

  css =
    (sheet.ownerNode.textContent || '') +
    (mediaSheet.ownerNode.textContent || '');

  if (linkSheet) {
    css += cssRulesToString(linkSheet.cssRules);
  }

  return css
}

function createStyleSheet(rules) {
  const cache = typeof Map === 'undefined' ? null : new Map();
  return {
    create: styles => {
      if (cache) {
        const cached = cache.get(styles);
        if (cached) {
          return cached
        }
      }
      const locals = {};

      for (const token in styles) {
        const rule = styles[token];
        if (process.env.NODE_ENV !== 'production') {
          validate(rule, null);
        }
        const compiled = compile(rule);
        locals[token] = Object.keys(compiled);
        Object.assign(rules, compiled);
      }

      if (cache) {
        cache.set(styles, locals);
      }

      return locals
    },
  }
}

function concatClassName(dest, className) {
  if (className.substr(0, 4) !== 'dss_') {
    return { shouldInject: false, className: `${className} ${dest}` }
  }
  const property = className.substr(0, className.indexOf('-'));
  if (dest.indexOf(property) > -1) {
    return { shouldInject: false, className: dest }
  }
  return { shouldInject: true, className: `${dest} ${className}` }
}

function createStyleResolver(sheets, rules) {
  const { sheet, mediaSheet } = sheets;
  const serverStyles = fromServer(sheets);
  let resolved = {};
  let injected = {};

  return {
    getStyleSheet() {
      // On the server we reset the caches.
      if (typeof window === 'undefined') {
        resolved = {};
        injected = {};
      }
      return sheets
    },
    resolve(style) {
      const stylesToString = style.join();

      if (resolved[stylesToString]) {
        return resolved[stylesToString]
      }

      let className = '';

      for (let i = style.length - 1; i >= 0; i--) {
        let current = style[i];
        if (!current) {
          continue
        }
        if (typeof current === 'string') {
          current = [current];
        }
        current.forEach(current => {
          const result = concatClassName(className, current);
          className = result.className;
          if (result.shouldInject && !injected[current]) {
            const rule = rules[current];
            if (rule && serverStyles.indexOf(current) === -1) {
(rule.charAt(0) === '@' ? mediaSheet : sheet).insertRule(rule);
            }
            injected[current] = true;
          }
        });
      }

      resolved[stylesToString] = className.trim();
      return resolved[stylesToString]
    },
  }
}

function createSheets(document = window.document) {
  const style = document.createElement('style');
  const mediaStyle = document.createElement('style');
  document.head.appendChild(style);
  document.head.appendChild(mediaStyle);

  return {
    get sheet() {
      return style.sheet
    },
    get mediaSheet() {
      return mediaStyle.sheet
    },
  }
}

function create(sheets = createSheets()) {
  const rules = {};

  if (!sheets.sheet || !sheets.mediaSheet) {
    throw new Error(
      `Create must be called with an object that contains two objects, sheet and mediaSheet,
      that implement the CSSStyleSheet interface.

      To preserve determinism media queries should be inserted in a separate style sheet,
      after the main sheet.
    `
    )
  }

  // Moves link tag between the two style tags so that:
  // 1. new regular rules are appended before
  // 2. new at rules are appended after
  // This is necessary to preserve determinism due to specificity.
  const linkNode = sheets.linkSheet && sheets.linkSheet.ownerNode;
  if (linkNode) {
    linkNode.parentNode.insertBefore(linkNode, sheets.mediaSheet.ownerNode);
  }

  return {
    StyleSheet: createStyleSheet(rules),
    StyleResolver: createStyleResolver(sheets, rules),
  }
}

const sheets = {
  sheet: createSheet(),
  mediaSheet: createSheet(),
};

const { StyleSheet, StyleResolver } = create(sheets);

// This function returns the extracted CSS to save in a .css file.
// It must be called after all the files are processed by Babel.
function getCss() {
  return [
    cssRulesToString(sheets.sheet.cssRules),
    cssRulesToString(sheets.mediaSheet.cssRules),
  ].join(' ')
}

function babel(babel) {
  return {
    name: 'style-sheet/babel',
    visitor: {
      ImportDeclaration(path, state) {
        const packageName = state.opts.packageName || 'style-sheet';
        if (path.node.source.value !== packageName) {
          return
        }
        const importName = state.opts.importName || 'StyleSheet';
        const specifier = path.get('specifiers').find(specifier => {
          return (
            specifier.isImportSpecifier() &&
            specifier.get('imported').node.name === importName
          )
        });
        if (!specifier) {
          return
        }

        // Find all the references to StyleSheet.create.
        const binding = path.scope.getBinding(specifier.node.local.name);

        if (!binding || !Array.isArray(binding.referencePaths)) {
          return
        }

        binding.referencePaths
          .map(referencePath => referencePath.parentPath.parentPath)
          .forEach(path => {
            if (path.isCallExpression()) {
              processReferencePath(babel, path, state);
            }
          });
      },
    },
  }
}

function processReferencePath(babel, path, state) {
  const t = babel.types;
  const cloneNode = t.cloneNode || t.cloneDeep;
  // From
  //
  //   StyleSheet.create({
  //     root: {
  //       color: 'red'
  //     }
  //   })
  //
  // grabs
  //
  //   {
  //     root: {
  //       color: 'red'
  //     }
  //   }
  const rulesPath = path.get('arguments')[0];
  const extractableProperties = [];

  // For each property
  //
  //   root: {
  //     color: 'red'
  //   }
  const properties = rulesPath.get('properties');
  properties.forEach(property => {
    // Ignore complex stuff like spread elements for now.
    if (!property.isObjectProperty()) {
      return
    }
    // Try to resolve to static...
    // evaluate() will also compile static styles, which are the ones
    // that we will extract to file.
    const evaluated = evaluate(babel, property.get('value'), state);

    if (evaluated.value === null) {
      return
    }
    extractableProperties.push(
      t.objectProperty(
        cloneNode(property.get('key').node),
        t.arrayExpression(evaluated.value.map(value => t.stringLiteral(value)))
      )
    );
    property.remove();
  });

  // If we couldn't resolve anything we exit.
  if (extractableProperties.length === 0) {
    return
  }

  const extractedStylesObjectLiteral = t.objectExpression(extractableProperties);

  // When some rules could not be extracted (maybe there are dynamic styles)
  // we will spread StyleSheet.create({...}) to the replacement object
  //
  //   ({
  //    static: [/* ... */],
  //    ...StyleSheet.create({
  //      someDynamicRule: {
  //        color: props.color,
  //      }
  //    })
  //   })
  if (properties.length !== extractableProperties.length) {
    extractedStylesObjectLiteral.properties.push(
      t.spreadElement(cloneNode(path.node))
    );
  }
  path.replaceWith(extractedStylesObjectLiteral);
}

function compileRule(rule) {
  const compiled = StyleSheet.create({ static: rule }).static;
  StyleResolver.resolve(compiled);
  return compiled
}

function evaluate(babel, path, state) {
  let result = evaluateSimple(path);
  if (result.confident) {
    return {
      value: compileRule(result.value),
      dependencies: [],
    }
  }

  try {
    result = evaluateComplex(
      path,
      babel.types,
      state.file.opts.filename,
      text => {
        return babel.transformSync(text, {
          babelrc: false,
          filename: state.file.opts.filename,
          plugins: [
            // Include this plugin to avoid extra config when using { module: false } for webpack
            '@babel/plugin-transform-modules-commonjs',
            '@babel/plugin-proposal-export-namespace-from',
            // We don't support dynamic imports when evaluating, but don't wanna syntax error
            // This will replace dynamic imports with an object that does nothing
            require.resolve('linaria/lib/babel/dynamic-import-noop'),
          ],
          exclude: /node_modules/,
        })
      }
    );

    if (result.value !== null) {
      result.value = compileRule(result.value);
    }
  } catch (error) {
    result = { value: null, dependencies: [] };
  }

  return result
}

exports.getCss = getCss;
exports.default = babel;
