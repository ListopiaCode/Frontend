(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
    (factory((global.styleSheet = {}),global.React));
}(this, (function (exports,React) { 'use strict';

    React = React && React.hasOwnProperty('default') ? React['default'] : React;

    /**
     * Created by schwarzkopfb on 15/11/17.
     */

    /**
     * FNV-1a hash generation init value.
     * It's exposed, because this allows user to override it.
     *
     * @type {number}
     */
    hash.BASE = 0x811c9dc5;

    /**
     * Generates 32 bit FNV-1a hash from the given string.
     * As explained here: http://isthe.com/chongo/tech/comp/fnv/
     *
     * @param s {string} String to generate hash from.
     * @returns {number} The result integer hash.
     */
    function hash(s) {
        var h = hash.BASE;

        for (var i = 0, l = s.length; i < l; i++) {
            h ^= s.charCodeAt(i);
            h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
        }

        return h >>> 0
    }

    var fnv1a = hash;

    function capitalizeString(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function prefixProperty(prefixProperties, property, style) {
      if (prefixProperties.hasOwnProperty(property)) {
        var newStyle = {};
        var requiredPrefixes = prefixProperties[property];
        var capitalizedProperty = capitalizeString(property);
        var keys = Object.keys(style);
        for (var i = 0; i < keys.length; i++) {
          var styleProperty = keys[i];
          if (styleProperty === property) {
            for (var j = 0; j < requiredPrefixes.length; j++) {
              newStyle[requiredPrefixes[j] + capitalizedProperty] = style[property];
            }
          }
          newStyle[styleProperty] = style[styleProperty];
        }
        return newStyle;
      }
      return style;
    }

    function prefixValue(plugins, property, value, style, metaData) {
      for (var i = 0, len = plugins.length; i < len; ++i) {
        var processedValue = plugins[i](property, value, style, metaData);

        // we can stop processing if a value is returned
        // as all plugin criteria are unique
        if (processedValue) {
          return processedValue;
        }
      }
    }

    function addIfNew(list, value) {
      if (list.indexOf(value) === -1) {
        list.push(value);
      }
    }

    function addNewValuesOnly(list, values) {
      if (Array.isArray(values)) {
        for (var i = 0, len = values.length; i < len; ++i) {
          addIfNew(list, values[i]);
        }
      } else {
        addIfNew(list, values);
      }
    }

    function isObject(value) {
      return value instanceof Object && !Array.isArray(value);
    }

    function createPrefixer(_ref) {
      var prefixMap = _ref.prefixMap,
          plugins = _ref.plugins;

      return function prefix(style) {
        for (var property in style) {
          var value = style[property];

          // handle nested objects
          if (isObject(value)) {
            style[property] = prefix(value);
            // handle array values
          } else if (Array.isArray(value)) {
            var combinedValue = [];

            for (var i = 0, len = value.length; i < len; ++i) {
              var processedValue = prefixValue(plugins, property, value[i], style, prefixMap);
              addNewValuesOnly(combinedValue, processedValue || value[i]);
            }

            // only modify the value if it was touched
            // by any plugin to prevent unnecessary mutations
            if (combinedValue.length > 0) {
              style[property] = combinedValue;
            }
          } else {
            var _processedValue = prefixValue(plugins, property, value, style, prefixMap);

            // only modify the value if it was touched
            // by any plugin to prevent unnecessary mutations
            if (_processedValue) {
              style[property] = _processedValue;
            }

            style = prefixProperty(prefixMap, property, style);
          }
        }

        return style;
      };
    }

    var w = ["Webkit"];
    var m = ["Moz"];
    var ms = ["ms"];
    var wm = ["Webkit", "Moz"];
    var wms = ["Webkit", "ms"];
    var wmms = ["Webkit", "Moz", "ms"];

    var data = {
      plugins: [],
      prefixMap: { "appearance": wm, "textEmphasisPosition": w, "textEmphasis": w, "textEmphasisStyle": w, "textEmphasisColor": w, "boxDecorationBreak": w, "maskImage": w, "maskMode": w, "maskRepeat": w, "maskPosition": w, "maskClip": w, "maskOrigin": w, "maskSize": w, "maskComposite": w, "mask": w, "maskBorderSource": w, "maskBorderMode": w, "maskBorderSlice": w, "maskBorderWidth": w, "maskBorderOutset": w, "maskBorderRepeat": w, "maskBorder": w, "maskType": w, "textDecorationStyle": w, "textDecorationSkip": w, "textDecorationLine": w, "textDecorationColor": w, "userSelect": wmms, "backdropFilter": w, "fontKerning": w, "scrollSnapType": wms, "scrollSnapPointsX": wms, "scrollSnapPointsY": wms, "scrollSnapDestination": wms, "scrollSnapCoordinate": wms, "clipPath": w, "shapeImageThreshold": w, "shapeImageMargin": w, "shapeImageOutside": w, "filter": w, "hyphens": wms, "flowInto": wms, "flowFrom": wms, "breakBefore": wms, "breakAfter": wms, "breakInside": wms, "regionFragment": wms, "writingMode": wms, "textOrientation": w, "tabSize": m, "fontFeatureSettings": w, "columnCount": w, "columnFill": w, "columnGap": w, "columnRule": w, "columnRuleColor": w, "columnRuleStyle": w, "columnRuleWidth": w, "columns": w, "columnSpan": w, "columnWidth": w, "wrapFlow": ms, "wrapThrough": ms, "wrapMargin": ms, "gridTemplateColumns": ms, "gridTemplateRows": ms, "gridTemplateAreas": ms, "gridTemplate": ms, "gridAutoColumns": ms, "gridAutoRows": ms, "gridAutoFlow": ms, "grid": ms, "gridRowStart": ms, "gridColumnStart": ms, "gridRowEnd": ms, "gridRow": ms, "gridColumn": ms, "gridColumnEnd": ms, "gridColumnGap": ms, "gridRowGap": ms, "gridArea": ms, "gridGap": ms, "textSizeAdjust": wms }
    };

    // https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip#Browser_compatibility
    function backgroundClip(property, value) {
      if (typeof value === 'string' && value === 'text') {
        return ['-webkit-text', 'text'];
      }
    }

    var prefixes = ['-webkit-', '-moz-', ''];

    var values = {
      'zoom-in': true,
      'zoom-out': true,
      grab: true,
      grabbing: true
    };

    function cursor(property, value) {
      if (property === 'cursor' && values.hasOwnProperty(value)) {
        return prefixes.map(function (prefix) {
          return prefix + value;
        });
      }
    }

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var isPrefixedValue_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isPrefixedValue;
    var regex = /-webkit-|-moz-|-ms-/;

    function isPrefixedValue(value) {
      return typeof value === 'string' && regex.test(value);
    }
    module.exports = exports['default'];
    });

    var isPrefixedValue = unwrapExports(isPrefixedValue_1);

    // http://caniuse.com/#search=cross-fade
    var prefixes$1 = ['-webkit-', ''];

    function crossFade(property, value) {
      if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('cross-fade(') > -1) {
        return prefixes$1.map(function (prefix) {
          return value.replace(/cross-fade\(/g, prefix + 'cross-fade(');
        });
      }
    }

    // http://caniuse.com/#feat=css-filter-function
    var prefixes$2 = ['-webkit-', ''];

    function filter(property, value) {
      if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('filter(') > -1) {
        return prefixes$2.map(function (prefix) {
          return value.replace(/filter\(/g, prefix + 'filter(');
        });
      }
    }

    var values$1 = {
      flex: ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex', 'flex'],
      'inline-flex': ['-webkit-inline-box', '-moz-inline-box', '-ms-inline-flexbox', '-webkit-inline-flex', 'inline-flex']
    };

    function flex(property, value) {
      if (property === 'display' && values$1.hasOwnProperty(value)) {
        return values$1[value];
      }
    }

    var alternativeValues = {
      'space-around': 'justify',
      'space-between': 'justify',
      'flex-start': 'start',
      'flex-end': 'end',
      'wrap-reverse': 'multiple',
      wrap: 'multiple'
    };

    var alternativeProps = {
      alignItems: 'WebkitBoxAlign',
      justifyContent: 'WebkitBoxPack',
      flexWrap: 'WebkitBoxLines',
      flexGrow: 'WebkitBoxFlex'
    };

    function flexboxOld(property, value, style) {
      if (property === 'flexDirection' && typeof value === 'string') {
        if (value.indexOf('column') > -1) {
          style.WebkitBoxOrient = 'vertical';
        } else {
          style.WebkitBoxOrient = 'horizontal';
        }
        if (value.indexOf('reverse') > -1) {
          style.WebkitBoxDirection = 'reverse';
        } else {
          style.WebkitBoxDirection = 'normal';
        }
      }
      if (alternativeProps.hasOwnProperty(property)) {
        style[alternativeProps[property]] = alternativeValues[value] || value;
      }
    }

    var prefixes$3 = ['-webkit-', '-moz-', ''];
    var values$2 = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/gi;

    function gradient(property, value) {
      if (typeof value === 'string' && !isPrefixedValue(value) && values$2.test(value)) {
        return prefixes$3.map(function (prefix) {
          return value.replace(values$2, function (grad) {
            return prefix + grad;
          });
        });
      }
    }

    // http://caniuse.com/#feat=css-image-set
    var prefixes$4 = ['-webkit-', ''];

    function imageSet(property, value) {
      if (typeof value === 'string' && !isPrefixedValue(value) && value.indexOf('image-set(') > -1) {
        return prefixes$4.map(function (prefix) {
          return value.replace(/image-set\(/g, prefix + 'image-set(');
        });
      }
    }

    function position(property, value) {
      if (property === 'position' && value === 'sticky') {
        return ['-webkit-sticky', 'sticky'];
      }
    }

    var prefixes$5 = ['-webkit-', '-moz-', ''];

    var properties = {
      maxHeight: true,
      maxWidth: true,
      width: true,
      height: true,
      columnWidth: true,
      minWidth: true,
      minHeight: true
    };
    var values$3 = {
      'min-content': true,
      'max-content': true,
      'fill-available': true,
      'fit-content': true,
      'contain-floats': true
    };

    function sizing(property, value) {
      if (properties.hasOwnProperty(property) && values$3.hasOwnProperty(value)) {
        return prefixes$5.map(function (prefix) {
          return prefix + value;
        });
      }
    }

    var uppercasePattern = /[A-Z]/g;
    var msPattern = /^ms-/;
    var cache = {};

    function hyphenateStyleName(string) {
        return string in cache
        ? cache[string]
        : cache[string] = string
          .replace(uppercasePattern, '-$&')
          .toLowerCase()
          .replace(msPattern, '-ms-');
    }

    var hyphenateStyleName_1 = hyphenateStyleName;

    var hyphenateProperty_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = hyphenateProperty;



    var _hyphenateStyleName2 = _interopRequireDefault(hyphenateStyleName_1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    function hyphenateProperty(property) {
      return (0, _hyphenateStyleName2.default)(property);
    }
    module.exports = exports['default'];
    });

    var hyphenateProperty = unwrapExports(hyphenateProperty_1);

    var properties$1 = {
      transition: true,
      transitionProperty: true,
      WebkitTransition: true,
      WebkitTransitionProperty: true,
      MozTransition: true,
      MozTransitionProperty: true
    };

    var prefixMapping = {
      Webkit: '-webkit-',
      Moz: '-moz-',
      ms: '-ms-'
    };

    function prefixValue$1(value, propertyPrefixMap) {
      if (isPrefixedValue(value)) {
        return value;
      }

      // only split multi values, not cubic beziers
      var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);

      for (var i = 0, len = multipleValues.length; i < len; ++i) {
        var singleValue = multipleValues[i];
        var values = [singleValue];
        for (var property in propertyPrefixMap) {
          var dashCaseProperty = hyphenateProperty(property);

          if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== 'order') {
            var prefixes = propertyPrefixMap[property];
            for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
              // join all prefixes and create a new value
              values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
            }
          }
        }

        multipleValues[i] = values.join(',');
      }

      return multipleValues.join(',');
    }

    function transition(property, value, style, propertyPrefixMap) {
      // also check for already prefixed transitions
      if (typeof value === 'string' && properties$1.hasOwnProperty(property)) {
        var outputValue = prefixValue$1(value, propertyPrefixMap);
        // if the property is already prefixed
        var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
          return !/-moz-|-ms-/.test(val);
        }).join(',');

        if (property.indexOf('Webkit') > -1) {
          return webkitOutput;
        }

        var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
          return !/-webkit-|-ms-/.test(val);
        }).join(',');

        if (property.indexOf('Moz') > -1) {
          return mozOutput;
        }

        style['Webkit' + capitalizeString(property)] = webkitOutput;
        style['Moz' + capitalizeString(property)] = mozOutput;
        return outputValue;
      }
    }

    var plugins = [backgroundClip, crossFade, cursor, filter, flexboxOld, gradient, imageSet, position, sizing, transition, flex];

    var prefix = createPrefixer({
      prefixMap: data.prefixMap,
      plugins: plugins
    });

    var unitless = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      // SVG-related properties
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    };
    var shortHandProperties = ['animation', 'background', 'border', 'border-bottom', 'border-left', 'border-radius', 'border-right', 'border-top', 'column-rule', 'columns', 'flex', 'flex-flow', 'font', 'grid', 'grid-area', 'grid-column', 'grid-row', 'grid-template', 'list-style', 'margin', 'offset', 'outline', 'overflow', 'padding', 'place-content', 'place-items', 'place-self', 'text-decoration', 'transition'];

    // Fork of https://github.com/jxnblk/object-style
    function createClassName(property, value, descendants, media) {
      return "dss_" + fnv1a(property + descendants + media).toString(36) + "-" + fnv1a(String(value)).toString(36);
    }

    var hyphenate = function hyphenate(s) {
      return s.replace(/[A-Z]|^ms/g, '-$&').toLowerCase();
    };

    var strigifyDeclaration = function strigifyDeclaration(dec) {
      var stringified = '';

      for (var prop in dec) {
        var value = dec[prop];

        if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            stringified += hyphenate(prop) + ':' + value[i] + ';';
          }
        } else {
          stringified += hyphenate(prop) + ':' + value + ';';
        }
      }

      return stringified;
    };

    function createRule(className, declaration, descendants, media) {
      var cls = '.' + className;
      var selector = descendants ? descendants.replace(/^&/, cls).replace(/&/g, cls) : cls;
      var rule = selector + '{' + strigifyDeclaration(declaration) + '}';
      if (!media) return rule;
      return media + '{' + rule + '}';
    }

    var parse = function parse(obj, descendants, media, opts) {
      var rules = {};

      for (var key in obj) {
        var value = obj[key];
        if (value === null || value === undefined) continue;

        switch (Object.prototype.toString.call(value)) {
          case '[object Object]':
            {
              var parsed = key.charAt(0) === '@' ? parse(value, descendants, key, opts) : parse(value, descendants + key, media, opts);
              Object.assign(rules, parsed);
              break;
            }

          default:
            {
              var _prefix;

              var className = createClassName(key, value, descendants, media);

              if (rules[className]) {
                break;
              }

              if (!unitless[key]) {
                if (typeof value === 'number') {
                  if (value !== 0) {
                    value += 'px';
                  }
                } else if (Array.isArray(value)) {
                  value = value.map(function (v) {
                    if (typeof v === 'number' && v !== 0) {
                      return v + 'px';
                    }

                    return v;
                  });
                }
              }

              var declaration = prefix((_prefix = {}, _prefix[key] = value, _prefix));
              var rule = createRule(className, declaration, descendants, media);
              rules[className] = rule;
              break;
            }
        }
      }

      return rules;
    };

    var compile = (function (obj) {
      if (!obj) {
        throw new Error('DSS parser invoked without a mandatory styles object.');
      }

      return parse(obj, '', '');
    });

    function error(message) {
      throw new Error("style-sheet: " + message);
    }

    function validate(obj) {
      for (var k in obj) {
        var key = k.trim();
        var value = obj[key];
        if (value === null) continue;
        var isDeclaration = Object.prototype.toString.call(value) !== '[object Object]';
        validateStr(key, isDeclaration);

        if (!isDeclaration) {
          validate(value);
        } else if (typeof value === 'string' && /!\s*important/.test(value)) {
          error('!important is not allowed');
        }
      }
    }
    function validateStr(key, isDeclaration) {
      if (isDeclaration) {
        // Value
        if (shortHandProperties.includes(key)) {
          error('`' + key + "`: style-sheet does't support shorthand properties at the moment. This CSS feature will likely be supported in the future. Please expand your shorthand properties for now." + ("\n Can't remember what is the long form for `" + key + "`? Ask Google \uD83D\uDC49  https://google.com/search?q=" + encodeURIComponent("css " + key + " properties")));
        }

        return;
      }

      if (key.charAt(0) === '@') {
        return;
      } // Selector


      if (key.split(',').length > 1) {
        error("Invalid nested selector: '" + key + "'. Selectors cannot be grouped.");
      }

      if (/::?(after|before|first-letter|first-line)/.test(key)) {
        error("Detected pseudo-element: '" + key + "'. Pseudo-elements are not supported. Please use regular elements.");
      }

      if (/:(matches|has|not|lang|any|current)/.test(key)) {
        error("Detected unsupported pseudo-class: '" + key + "'.");
      }

      var split = key.split(/\s*[+>~]\s*/g);

      switch (split.length) {
        case 2:
          if (split[0].charAt(0) !== ':') {
            error("Invalid nested selector: '" + key + "'. " + 'The left part of a combinator selector must be a pseudo-class eg. `:hover`.');
          }

          if (split[1] !== '&') {
            error("Invalid nested selector: '" + key + "'. " + 'The right part of a combinator selector must be `&`.');
          }

          break;

        case 1:
          if (split[0].indexOf(' ') > -1) {
            error("Invalid nested selector: " + key + ". Complex selectors are not supported.");
          }

          if (split[0].charAt(0) !== '&') {
            error("Invalid nested selector: '" + key + "'. " + 'A pseudo-class selector should reference its parent with `&` eg. `&:hover {}`.');
          }

          break;

        default:
          error("Invalid nested selector: " + key + ".");
      }

      if (/\[/.test(key)) {
        error("Invalid selector: " + key + ". Cannot use attribute selectors, please use only class selectors.");
      }
    }

    function Sheet() {
      var _this = this;

      this.cssRules = {
        length: 0
      };

      this.insertRule = function (rule, index) {
        if (index === void 0) {
          index = _this.cssRules.length;
        }

        if (index > _this.cssRules.length) {
          throw new Error('IndexSizeError');
        }

        _this.cssRules[index] = {
          cssText: rule
        };
        var insertedIndex = index;

        if (index === _this.cssRules.length) {
          _this.cssRules.length++;
        }

        return insertedIndex;
      };
    }

    function createSheet() {
      return new Sheet();
    }
    function cssRulesToString(rules) {
      return Array.prototype.reduce.call(rules, // eslint-disable-next-line prefer-arrow-callback
      function (css, rule) {
        return css + rule.cssText;
      }, '');
    }
    function flush(sheet) {
      if (typeof window !== 'undefined') {
        throw new Error('This method is only avaliable server side.');
      }

      var css = cssRulesToString(sheet.cssRules);
      sheet.cssRules = {
        length: 0
      };
      return css;
    }
    function fromServer(sheets) {
      var css = '';
      var sheet = sheets.sheet,
          mediaSheet = sheets.mediaSheet,
          linkSheet = sheets.linkSheet; // We likely are server side rendering.

      if (!sheet.ownerNode) {
        return css;
      }

      css = (sheet.ownerNode.textContent || '') + (mediaSheet.ownerNode.textContent || '');

      if (linkSheet) {
        css += cssRulesToString(linkSheet.cssRules);
      }

      return css;
    }

    function createStyleSheet(rules) {
      var cache = typeof Map === 'undefined' ? null : new Map();
      return {
        create: function create(styles) {
          if (cache) {
            var cached = cache.get(styles);

            if (cached) {
              return cached;
            }
          }

          var locals = {};

          for (var token in styles) {
            var rule = styles[token];

            {
              validate(rule, null);
            }

            var compiled = compile(rule);
            locals[token] = Object.keys(compiled);
            Object.assign(rules, compiled);
          }

          if (cache) {
            cache.set(styles, locals);
          }

          return locals;
        }
      };
    }

    function concatClassName(dest, className) {
      if (className.substr(0, 4) !== 'dss_') {
        return {
          shouldInject: false,
          className: className + " " + dest
        };
      }

      var property = className.substr(0, className.indexOf('-'));

      if (dest.indexOf(property) > -1) {
        return {
          shouldInject: false,
          className: dest
        };
      }

      return {
        shouldInject: true,
        className: dest + " " + className
      };
    }

    function createStyleResolver(sheets, rules) {
      var sheet = sheets.sheet,
          mediaSheet = sheets.mediaSheet;
      var serverStyles = fromServer(sheets);
      var resolved = {};
      var injected = {};
      return {
        getStyleSheet: function getStyleSheet() {
          // On the server we reset the caches.
          if (typeof window === 'undefined') {
            resolved = {};
            injected = {};
          }

          return sheets;
        },
        resolve: function resolve(style) {
          var stylesToString = style.join();

          if (resolved[stylesToString]) {
            return resolved[stylesToString];
          }

          var className = '';

          for (var i = style.length - 1; i >= 0; i--) {
            var current = style[i];

            if (!current) {
              continue;
            }

            if (typeof current === 'string') {
              current = [current];
            }

            current.forEach(function (current) {
              var result = concatClassName(className, current);
              className = result.className;

              if (result.shouldInject && !injected[current]) {
                var rule = rules[current];

                if (rule && serverStyles.indexOf(current) === -1) {
                  (rule.charAt(0) === '@' ? mediaSheet : sheet).insertRule(rule);
                }

                injected[current] = true;
              }
            });
          }

          resolved[stylesToString] = className.trim();
          return resolved[stylesToString];
        }
      };
    }

    function createSheets(document) {
      if (document === void 0) {
        document = window.document;
      }

      var style = document.createElement('style');
      var mediaStyle = document.createElement('style');
      document.head.appendChild(style);
      document.head.appendChild(mediaStyle);
      return {
        get sheet() {
          return style.sheet;
        },

        get mediaSheet() {
          return mediaStyle.sheet;
        }

      };
    }
    function create(sheets) {
      if (sheets === void 0) {
        sheets = createSheets();
      }

      var rules = {};

      if (!sheets.sheet || !sheets.mediaSheet) {
        throw new Error("Create must be called with an object that contains two objects, sheet and mediaSheet,\n      that implement the CSSStyleSheet interface.\n\n      To preserve determinism media queries should be inserted in a separate style sheet,\n      after the main sheet.\n    ");
      } // Moves link tag between the two style tags so that:
      // 1. new regular rules are appended before
      // 2. new at rules are appended after
      // This is necessary to preserve determinism due to specificity.


      var linkNode = sheets.linkSheet && sheets.linkSheet.ownerNode;

      if (linkNode) {
        linkNode.parentNode.insertBefore(linkNode, sheets.mediaSheet.ownerNode);
      }

      return {
        StyleSheet: createStyleSheet(rules),
        StyleResolver: createStyleResolver(sheets, rules)
      };
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function createCreateElement(_ref) {
      var StyleSheet = _ref.StyleSheet,
          StyleResolver = _ref.StyleResolver;
      return function (tag, props) {
        for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          children[_key - 2] = arguments[_key];
        }

        if (props && props.css) {
          var css = props.css,
              className = props.className,
              rest = _objectWithoutPropertiesLoose(props, ["css", "className"]);

          var rules = [];

          if (Array.isArray(css)) {
            rules = css.map(function (rule) {
              return StyleSheet.create({
                rule: rule
              }).rule;
            });
          } else {
            rules.push(StyleSheet.create({
              rule: css
            }).rule);
          }

          if (className) {
            // className takes precedence over the css prop
            // this allows parent components to style the current one.
            rules.push(className.indexOf('dss_') === -1 ? [className] : className.split(' '));
          }

          rest.className = StyleResolver.resolve(rules);
          return React.createElement.apply(React, [tag, rest].concat(children));
        }

        return React.createElement.apply(React, [tag, props].concat(children));
      };
    }

    var isBrowser = typeof window !== 'undefined';

    var createSheets$1 = function createSheets$$1() {
      var style;
      var mediaStyle;
      var linkStyle = null;

      if (isBrowser) {
        style = document.querySelector('#__style_sheet__');

        if (!style) {
          style = document.createElement('style');
          document.head.appendChild(style);
        }

        mediaStyle = document.querySelector('#__style_sheet_media__');

        if (!mediaStyle) {
          mediaStyle = document.createElement('style');
          document.head.appendChild(mediaStyle);
        }

        linkStyle = document.querySelector('#__style_sheet_extracted__');
      } else {
        style = {
          sheet: createSheet()
        };
        mediaStyle = {
          sheet: createSheet()
        };
      }

      return {
        get sheet() {
          return style.sheet;
        },

        get mediaSheet() {
          return mediaStyle.sheet;
        },

        linkSheet: linkStyle && linkStyle.sheet
      };
    };

    var sheets = createSheets$1();

    var _create = create(sheets),
        StyleSheet = _create.StyleSheet,
        StyleResolver = _create.StyleResolver;
    function flushServer() {
      var sheets = StyleResolver.getStyleSheet();
      return [{
        id: '__style_sheet__',
        css: flush(sheets.sheet)
      }, {
        id: '__style_sheet_media__',
        css: flush(sheets.mediaSheet)
      }];
    }
    var createElement = createCreateElement({
      StyleSheet: StyleSheet,
      StyleResolver: StyleResolver
    });

    exports.StyleSheet = StyleSheet;
    exports.StyleResolver = StyleResolver;
    exports.flushServer = flushServer;
    exports.createElement = createElement;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
