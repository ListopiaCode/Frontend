"use strict";

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var fs = require('fs');

var path = require('path');

var mkdirp = require('mkdirp');

var normalize = require('normalize-path');
/* $FlowFixMe */


var Module = require('module');

var loaderUtils = require('loader-utils');

var transform = require('./transform');

module.exports = function loader(content, inputSourceMap) {
  var _this = this;

  var _ref = loaderUtils.getOptions(this) || {},
      sourceMap = _ref.sourceMap,
      _ref$cacheDirectory = _ref.cacheDirectory,
      cacheDirectory = _ref$cacheDirectory === void 0 ? '.linaria-cache' : _ref$cacheDirectory,
      rest = _objectWithoutProperties(_ref, ["sourceMap", "cacheDirectory"]);

  var outputFilename = path.join(path.isAbsolute(cacheDirectory) ? cacheDirectory : path.join(process.cwd(), cacheDirectory), path.relative(process.cwd(), this.resourcePath.replace(/\.[^.]+$/, '.linaria.css')));
  var result = transform(content, {
    filename: this.resourcePath,
    inputSourceMap: inputSourceMap != null ? inputSourceMap : undefined,
    outputFilename: outputFilename,
    pluginOptions: rest
  });

  if (result.cssText) {
    var cssText = result.cssText;

    if (sourceMap) {
      cssText += "/*# sourceMappingURL=data:application/json;base64,".concat(Buffer.from(result.cssSourceMapText || '').toString('base64'), "*/");
    }

    if (result.dependencies && result.dependencies.length) {
      result.dependencies.forEach(function (dep) {
        try {
          var f = Module._resolveFilename(dep, {
            id: _this.resourcePath,
            filename: _this.resourcePath,
            paths: Module._nodeModulePaths(path.dirname(_this.resourcePath))
          });

          _this.addDependency(f);
        } catch (e) {// Ignore
        }
      });
    } // Read the file first to compare the content
    // Write the new content only if it's changed
    // This will prevent unnecessary WDS reloads


    var currentCssText;

    try {
      currentCssText = fs.readFileSync(outputFilename, 'utf-8');
    } catch (e) {// Ignore error
    }

    if (currentCssText !== cssText) {
      mkdirp.sync(path.dirname(outputFilename));
      fs.writeFileSync(outputFilename, cssText);
    }

    this.callback(null, "".concat(result.code, "\n\nrequire(\"").concat(normalize(outputFilename), "\")"), result.sourceMap);
    return;
  }

  this.callback(null, result.code, result.sourceMap);
};
//# sourceMappingURL=loader.js.map