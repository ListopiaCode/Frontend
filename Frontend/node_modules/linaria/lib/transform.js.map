{"version":3,"sources":["../src/transform.js"],"names":["path","require","babel","stylis","SourceMapGenerator","STYLIS_DECLARATION","module","exports","transform","code","options","test","sourceMap","inputSourceMap","ast","parseSync","filename","caller","name","transformFromAstSync","presets","resolve","pluginOptions","babelrc","configFile","sourceMaps","sourceFileName","metadata","transformedCode","map","linaria","rules","replacements","dependencies","mappings","cssText","use","context","decl","outputFilename","replace","match","p1","p2","p3","relative","dirname","Object","keys","forEach","selector","index","push","generated","line","column","original","start","cssSourceMapText","length","generator","file","mapping","addMapping","assign","source","setSourceContent","toString"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport type { Options as PluginOptions } from './babel/extract';\n\nconst path = require('path');\nconst babel = require('@babel/core');\nconst stylis = require('stylis');\nconst { SourceMapGenerator } = require('source-map');\n\ntype Location = {\n  line: number,\n  column: number,\n};\n\ntype Result = {\n  code: string,\n  sourceMap: ?Object,\n  cssText?: string,\n  cssSourceMapText?: string,\n  dependencies?: string[],\n  rules?: {\n    [className: string]: {\n      cssText: string,\n      displayName: string,\n      start: ?Location,\n    },\n  },\n  replacements?: Array<{\n    original: { start: Location, end: Location },\n    length: number,\n  }>,\n};\n\ntype Options = {\n  filename: string,\n  outputFilename?: string,\n  inputSourceMap?: Object,\n  pluginOptions?: $Shape<PluginOptions>,\n};\n\nconst STYLIS_DECLARATION = 1;\n\nmodule.exports = function transform(code: string, options: Options): Result {\n  // Check if the file contains `css` or `styled` words first\n  // Otherwise we should skip transforming\n  if (!/\\b(styled|css)/.test(code)) {\n    return {\n      code,\n      sourceMap: options.inputSourceMap,\n    };\n  }\n\n  // Parse the code first so babel uses user's babel config for parsing\n  // We don't want to use user's config when transforming the code\n  const ast = babel.parseSync(code, {\n    filename: options.filename,\n    caller: { name: 'linaria' },\n  });\n\n  const { metadata, code: transformedCode, map } = babel.transformFromAstSync(\n    ast,\n    code,\n    {\n      filename: options.filename,\n      presets: [[require.resolve('./babel'), options.pluginOptions]],\n      babelrc: false,\n      configFile: false,\n      sourceMaps: true,\n      sourceFileName: options.filename,\n      inputSourceMap: options.inputSourceMap,\n    }\n  );\n\n  if (!metadata.linaria) {\n    return {\n      code,\n      sourceMap: options.inputSourceMap,\n    };\n  }\n\n  const { rules, replacements, dependencies } = metadata.linaria;\n  const mappings = [];\n\n  let cssText = '';\n\n  stylis.use(null)((context, decl) => {\n    if (context === STYLIS_DECLARATION && options.outputFilename) {\n      // When writing to a file, we need to adjust the relative paths inside url(..) expressions\n      // It'll allow css-loader to resolve an imported asset properly\n      return decl.replace(\n        /\\b(url\\()(\\.[^)]+)(\\))/,\n        (match, p1, p2, p3) =>\n          p1 +\n          // Replace asset path with new path relative to the output CSS\n          path.relative(\n            /* $FlowFixMe */\n            path.dirname(options.outputFilename),\n            // Get the absolute path to the asset from the path relative to the JS file\n            path.resolve(path.dirname(options.filename), p2)\n          ) +\n          p3\n      );\n    }\n\n    return decl;\n  });\n\n  Object.keys(rules).forEach((selector, index) => {\n    mappings.push({\n      generated: {\n        line: index + 1,\n        column: 0,\n      },\n      original: rules[selector].start,\n      name: selector,\n    });\n\n    // Run each rule through stylis to support nesting\n    cssText += `${stylis(selector, rules[selector].cssText)}\\n`;\n  });\n\n  return {\n    code: transformedCode,\n    cssText,\n    rules,\n    replacements,\n    dependencies,\n    sourceMap: map,\n\n    get cssSourceMapText() {\n      if (mappings && mappings.length) {\n        const generator = new SourceMapGenerator({\n          file: options.filename.replace(/\\.js$/, '.css'),\n        });\n\n        mappings.forEach(mapping =>\n          generator.addMapping(\n            Object.assign({}, mapping, { source: options.filename })\n          )\n        );\n\n        generator.setSourceContent(options.filename, code);\n\n        return generator.toString();\n      }\n\n      return '';\n    },\n  };\n};\n"],"file":"transform.js"}