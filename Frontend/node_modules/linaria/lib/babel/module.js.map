{"version":3,"sources":["../../src/babel/module.js"],"names":["NativeModule","require","vm","fs","path","cache","NOOP","Module","filename","Object","defineProperties","id","value","writable","paths","freeze","_nodeModulePaths","dirname","exports","bind","resolve","ensure","extensions","_extensions","added","forEach","ext","push","_resolveFilename","isAbsolute","Error","m","transform","includes","extname","code","readFileSync","test","JSON","parse","evaluate","text","script","Script","runInContext","createContext","module","process","env","NODE_ENV","__filename","__dirname","invalidate"],"mappings":"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","sourcesContent":["/**\n * This is a custom implementation for the module system for evaluating code.\n *\n * This serves 2 purposes:\n * - Avoid leakage from evaled code to module cache in current context, e.g. `babel-register`\n * - Allow us to invalidate the module cache without affecting other stuff, necessary for rebuilds\n *\n * We also use it to transpile the code with Babel by default.\n * We also store source maps for it to provide correct error stacktraces.\n *\n * @flow\n */\n\n/* $FlowFixMe */\nconst NativeModule = require('module');\nconst vm = require('vm');\nconst fs = require('fs');\nconst path = require('path');\n\n// Separate cache for evaled modules\nlet cache = {};\n\nconst NOOP = () => {};\n\nclass Module {\n  static invalidate: () => void;\n\n  id: string;\n\n  filename: string;\n\n  paths: string;\n\n  require: (id: string) => any;\n\n  exports: any;\n\n  extensions: string[];\n\n  transform: ?(text: string) => { code: string };\n\n  constructor(filename: string) {\n    Object.defineProperties(this, {\n      id: {\n        value: filename,\n        writable: false,\n      },\n      filename: {\n        value: filename,\n        writable: false,\n      },\n      paths: {\n        value: Object.freeze(\n          NativeModule._nodeModulePaths(path.dirname(filename))\n        ),\n        writable: false,\n      },\n    });\n\n    this.exports = {};\n    this.require = this.require.bind(this);\n    this.require.resolve = this.resolve.bind(this);\n    this.require.ensure = NOOP;\n    this.require.cache = cache;\n\n    // We support following extensions by default\n    this.extensions = ['.json', '.js', '.ts', '.tsx'];\n  }\n\n  resolve(id: string) {\n    const extensions = NativeModule._extensions;\n    const added = [];\n\n    try {\n      // Check for supported extensions\n      this.extensions.forEach(ext => {\n        if (ext in extensions) {\n          return;\n        }\n\n        // When an extension is not supported, add it\n        // And keep track of it to clean it up after resolving\n        // Use noop for the tranform function since we handle it\n        extensions[ext] = NOOP;\n        added.push(ext);\n      });\n\n      // Resolve the module using node's resolve algorithm\n      return NativeModule._resolveFilename(id, this);\n    } finally {\n      // Cleanup the extensions we added to restore previous behaviour\n      added.forEach(ext => delete extensions[ext]);\n    }\n  }\n\n  require(id: string) {\n    // Resolve module id (and filename) relatively to parent module\n    const filename = this.resolve(id);\n\n    if (filename === id && !path.isAbsolute(id)) {\n      // Native Node modules\n      throw new Error(\n        `Unable to import \"${id}\". Importing Node builtins is not supported in the sandbox.`\n      );\n    }\n\n    let m = cache[filename];\n\n    if (!m) {\n      // Create the module if cached module is not available\n      m = new Module(filename);\n      m.transform = this.transform;\n\n      // Store it in cache at this point with, otherwise\n      // we would end up in infinite loop with cyclic dependencies\n      cache[filename] = m;\n\n      if (this.extensions.includes(path.extname(filename))) {\n        // To evaluate the file, we need to read it first\n        const code = fs.readFileSync(filename, 'utf-8');\n\n        if (/\\.json$/.test(filename)) {\n          // For JSON files, parse it to a JS object similar to Node\n          m.exports = JSON.parse(code);\n        } else {\n          // For JS/TS files, evaluate the module\n          // The module will be transpiled using provided transform\n          m.evaluate(code);\n        }\n      } else {\n        // For non JS/JSON requires, just export the id\n        // This is to support importing assets in webpack\n        // The module will be resolved by css-loader\n        m.exports = id;\n      }\n    }\n\n    return m.exports;\n  }\n\n  evaluate(text: string) {\n    // For JavaScript files, we need to transpile it and to get the exports of the module\n    const code = this.transform ? this.transform(text).code : text;\n\n    const script = new vm.Script(code, {\n      filename: this.filename,\n    });\n\n    script.runInContext(\n      vm.createContext({\n        module: this,\n        exports: this.exports,\n        require: this.require,\n        process: Object.freeze({\n          env: Object.freeze({\n            NODE_ENV: process.env.NODE_ENV,\n          }),\n        }),\n        __filename: this.filename,\n        __dirname: path.dirname(this.filename),\n      })\n    );\n  }\n}\n\nModule.invalidate = () => {\n  cache = {};\n};\n\nmodule.exports = Module;\n"],"file":"module.js"}